/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    getU32Encoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
    SolanaError,
    type Address,
    type ClientWithPayer,
    type ClientWithRpc,
    type ClientWithTransactionPlanning,
    type ClientWithTransactionSending,
    type GetAccountInfoApi,
    type GetMultipleAccountsApi,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import {
    addSelfFetchFunctions,
    addSelfPlanAndSendFunctions,
    type SelfFetchFunctions,
    type SelfPlanAndSendFunctions,
} from '@solana/kit/program-client-core';
import { getNonceCodec, type Nonce, type NonceArgs } from '../accounts';
import {
    getAdvanceNonceAccountInstruction,
    getAllocateInstruction,
    getAllocateWithSeedInstruction,
    getAssignInstruction,
    getAssignWithSeedInstruction,
    getAuthorizeNonceAccountInstruction,
    getCreateAccountInstruction,
    getCreateAccountWithSeedInstruction,
    getInitializeNonceAccountInstruction,
    getTransferSolInstruction,
    getTransferSolWithSeedInstruction,
    getUpgradeNonceAccountInstruction,
    getWithdrawNonceAccountInstruction,
    parseAdvanceNonceAccountInstruction,
    parseAllocateInstruction,
    parseAllocateWithSeedInstruction,
    parseAssignInstruction,
    parseAssignWithSeedInstruction,
    parseAuthorizeNonceAccountInstruction,
    parseCreateAccountInstruction,
    parseCreateAccountWithSeedInstruction,
    parseInitializeNonceAccountInstruction,
    parseTransferSolInstruction,
    parseTransferSolWithSeedInstruction,
    parseUpgradeNonceAccountInstruction,
    parseWithdrawNonceAccountInstruction,
    type AdvanceNonceAccountInput,
    type AdvanceNonceAccountInstruction,
    type AllocateInput,
    type AllocateInstruction,
    type AllocateWithSeedInput,
    type AllocateWithSeedInstruction,
    type AssignInput,
    type AssignInstruction,
    type AssignWithSeedInput,
    type AssignWithSeedInstruction,
    type AuthorizeNonceAccountInput,
    type AuthorizeNonceAccountInstruction,
    type CreateAccountInput,
    type CreateAccountInstruction,
    type CreateAccountWithSeedInput,
    type CreateAccountWithSeedInstruction,
    type InitializeNonceAccountInput,
    type InitializeNonceAccountInstruction,
    type ParsedAdvanceNonceAccountInstruction,
    type ParsedAllocateInstruction,
    type ParsedAllocateWithSeedInstruction,
    type ParsedAssignInstruction,
    type ParsedAssignWithSeedInstruction,
    type ParsedAuthorizeNonceAccountInstruction,
    type ParsedCreateAccountInstruction,
    type ParsedCreateAccountWithSeedInstruction,
    type ParsedInitializeNonceAccountInstruction,
    type ParsedTransferSolInstruction,
    type ParsedTransferSolWithSeedInstruction,
    type ParsedUpgradeNonceAccountInstruction,
    type ParsedWithdrawNonceAccountInstruction,
    type TransferSolInput,
    type TransferSolInstruction,
    type TransferSolWithSeedInput,
    type TransferSolWithSeedInstruction,
    type UpgradeNonceAccountInput,
    type UpgradeNonceAccountInstruction,
    type WithdrawNonceAccountInput,
    type WithdrawNonceAccountInstruction,
} from '../instructions';

export const SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;

export enum SystemAccount {
    Nonce,
}

export enum SystemInstruction {
    CreateAccount,
    Assign,
    TransferSol,
    CreateAccountWithSeed,
    AdvanceNonceAccount,
    WithdrawNonceAccount,
    InitializeNonceAccount,
    AuthorizeNonceAccount,
    Allocate,
    AllocateWithSeed,
    AssignWithSeed,
    TransferSolWithSeed,
    UpgradeNonceAccount,
}

export function identifySystemInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): SystemInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU32Encoder().encode(0), 0)) {
        return SystemInstruction.CreateAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(1), 0)) {
        return SystemInstruction.Assign;
    }
    if (containsBytes(data, getU32Encoder().encode(2), 0)) {
        return SystemInstruction.TransferSol;
    }
    if (containsBytes(data, getU32Encoder().encode(3), 0)) {
        return SystemInstruction.CreateAccountWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(4), 0)) {
        return SystemInstruction.AdvanceNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(5), 0)) {
        return SystemInstruction.WithdrawNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(6), 0)) {
        return SystemInstruction.InitializeNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(7), 0)) {
        return SystemInstruction.AuthorizeNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(8), 0)) {
        return SystemInstruction.Allocate;
    }
    if (containsBytes(data, getU32Encoder().encode(9), 0)) {
        return SystemInstruction.AllocateWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(10), 0)) {
        return SystemInstruction.AssignWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(11), 0)) {
        return SystemInstruction.TransferSolWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(12), 0)) {
        return SystemInstruction.UpgradeNonceAccount;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, {
        instructionData: data,
        programName: 'system',
    });
}

export type ParsedSystemInstruction<TProgram extends string = '11111111111111111111111111111111'> =
    | ({ instructionType: SystemInstruction.CreateAccount } & ParsedCreateAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.Assign } & ParsedAssignInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.TransferSol } & ParsedTransferSolInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.CreateAccountWithSeed } & ParsedCreateAccountWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AdvanceNonceAccount } & ParsedAdvanceNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.WithdrawNonceAccount } & ParsedWithdrawNonceAccountInstruction<TProgram>)
    | ({
          instructionType: SystemInstruction.InitializeNonceAccount;
      } & ParsedInitializeNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AuthorizeNonceAccount } & ParsedAuthorizeNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.Allocate } & ParsedAllocateInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AllocateWithSeed } & ParsedAllocateWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AssignWithSeed } & ParsedAssignWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.TransferSolWithSeed } & ParsedTransferSolWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.UpgradeNonceAccount } & ParsedUpgradeNonceAccountInstruction<TProgram>);

export function parseSystemInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedSystemInstruction<TProgram> {
    const instructionType = identifySystemInstruction(instruction);
    switch (instructionType) {
        case SystemInstruction.CreateAccount: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.CreateAccount, ...parseCreateAccountInstruction(instruction) };
        }
        case SystemInstruction.Assign: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.Assign, ...parseAssignInstruction(instruction) };
        }
        case SystemInstruction.TransferSol: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.TransferSol, ...parseTransferSolInstruction(instruction) };
        }
        case SystemInstruction.CreateAccountWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.CreateAccountWithSeed,
                ...parseCreateAccountWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.AdvanceNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AdvanceNonceAccount,
                ...parseAdvanceNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.WithdrawNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.WithdrawNonceAccount,
                ...parseWithdrawNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.InitializeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.InitializeNonceAccount,
                ...parseInitializeNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.AuthorizeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AuthorizeNonceAccount,
                ...parseAuthorizeNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.Allocate: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.Allocate, ...parseAllocateInstruction(instruction) };
        }
        case SystemInstruction.AllocateWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AllocateWithSeed,
                ...parseAllocateWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.AssignWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AssignWithSeed,
                ...parseAssignWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.TransferSolWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.TransferSolWithSeed,
                ...parseTransferSolWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.UpgradeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.UpgradeNonceAccount,
                ...parseUpgradeNonceAccountInstruction(instruction),
            };
        }
        default:
            throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, {
                instructionType: instructionType as string,
                programName: 'system',
            });
    }
}

export type SystemPlugin = { accounts: SystemPluginAccounts; instructions: SystemPluginInstructions };

export type SystemPluginAccounts = { nonce: ReturnType<typeof getNonceCodec> & SelfFetchFunctions<NonceArgs, Nonce> };

export type SystemPluginInstructions = {
    createAccount: (input: CreateAccountInput) => CreateAccountInstruction & SelfPlanAndSendFunctions;
    assign: (input: AssignInput) => AssignInstruction & SelfPlanAndSendFunctions;
    transferSol: (input: TransferSolInput) => TransferSolInstruction & SelfPlanAndSendFunctions;
    createAccountWithSeed: (
        input: CreateAccountWithSeedInput,
    ) => CreateAccountWithSeedInstruction & SelfPlanAndSendFunctions;
    advanceNonceAccount: (input: AdvanceNonceAccountInput) => AdvanceNonceAccountInstruction & SelfPlanAndSendFunctions;
    withdrawNonceAccount: (
        input: WithdrawNonceAccountInput,
    ) => WithdrawNonceAccountInstruction & SelfPlanAndSendFunctions;
    initializeNonceAccount: (
        input: InitializeNonceAccountInput,
    ) => InitializeNonceAccountInstruction & SelfPlanAndSendFunctions;
    authorizeNonceAccount: (
        input: AuthorizeNonceAccountInput,
    ) => AuthorizeNonceAccountInstruction & SelfPlanAndSendFunctions;
    allocate: (input: AllocateInput) => AllocateInstruction & SelfPlanAndSendFunctions;
    allocateWithSeed: (input: AllocateWithSeedInput) => AllocateWithSeedInstruction & SelfPlanAndSendFunctions;
    assignWithSeed: (input: AssignWithSeedInput) => AssignWithSeedInstruction & SelfPlanAndSendFunctions;
    transferSolWithSeed: (input: TransferSolWithSeedInput) => TransferSolWithSeedInstruction & SelfPlanAndSendFunctions;
    upgradeNonceAccount: (input: UpgradeNonceAccountInput) => UpgradeNonceAccountInstruction & SelfPlanAndSendFunctions;
};

export type SystemPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> &
    ClientWithPayer &
    ClientWithTransactionPlanning &
    ClientWithTransactionSending;

export function systemProgram() {
    return <T extends SystemPluginRequirements>(client: T) => {
        return {
            ...client,
            system: {
                accounts: { nonce: addSelfFetchFunctions(client, getNonceCodec()) },
                instructions: {
                    createAccount: (input: MakeOptional<CreateAccountInput, 'payer'>) =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getCreateAccountInstruction({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    assign: (input: AssignInput) => addSelfPlanAndSendFunctions(client, getAssignInstruction(input)),
                    transferSol: (input: TransferSolInput) =>
                        addSelfPlanAndSendFunctions(client, getTransferSolInstruction(input)),
                    createAccountWithSeed: (input: MakeOptional<CreateAccountWithSeedInput, 'payer'>) =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getCreateAccountWithSeedInstruction({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    advanceNonceAccount: (input: AdvanceNonceAccountInput) =>
                        addSelfPlanAndSendFunctions(client, getAdvanceNonceAccountInstruction(input)),
                    withdrawNonceAccount: (input: WithdrawNonceAccountInput) =>
                        addSelfPlanAndSendFunctions(client, getWithdrawNonceAccountInstruction(input)),
                    initializeNonceAccount: (input: InitializeNonceAccountInput) =>
                        addSelfPlanAndSendFunctions(client, getInitializeNonceAccountInstruction(input)),
                    authorizeNonceAccount: (input: AuthorizeNonceAccountInput) =>
                        addSelfPlanAndSendFunctions(client, getAuthorizeNonceAccountInstruction(input)),
                    allocate: (input: AllocateInput) =>
                        addSelfPlanAndSendFunctions(client, getAllocateInstruction(input)),
                    allocateWithSeed: (input: AllocateWithSeedInput) =>
                        addSelfPlanAndSendFunctions(client, getAllocateWithSeedInstruction(input)),
                    assignWithSeed: (input: AssignWithSeedInput) =>
                        addSelfPlanAndSendFunctions(client, getAssignWithSeedInstruction(input)),
                    transferSolWithSeed: (input: TransferSolWithSeedInput) =>
                        addSelfPlanAndSendFunctions(client, getTransferSolWithSeedInstruction(input)),
                    upgradeNonceAccount: (input: UpgradeNonceAccountInput) =>
                        addSelfPlanAndSendFunctions(client, getUpgradeNonceAccountInstruction(input)),
                },
            } as SystemPlugin,
        };
    };
}

type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
