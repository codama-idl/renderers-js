/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    fixEncoderSize,
    getBytesEncoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
    SolanaError,
    type Address,
    type ClientWithPayer,
    type ClientWithRpc,
    type ClientWithTransactionPlanning,
    type ClientWithTransactionSending,
    type GetAccountInfoApi,
    type GetMultipleAccountsApi,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import {
    addSelfFetchFunctions,
    addSelfPlanAndSendFunctions,
    type SelfFetchFunctions,
    type SelfPlanAndSendFunctions,
} from '@solana/kit/program-client-core';
import { getGuardV1Codec, type GuardV1, type GuardV1Args } from '../accounts';
import {
    getCreateGuardInstructionAsync,
    getExecuteInstructionAsync,
    getInitializeInstructionAsync,
    getUpdateGuardInstructionAsync,
    parseCreateGuardInstruction,
    parseExecuteInstruction,
    parseInitializeInstruction,
    parseUpdateGuardInstruction,
    type CreateGuardAsyncInput,
    type CreateGuardInstruction,
    type ExecuteAsyncInput,
    type ExecuteInstruction,
    type InitializeAsyncInput,
    type InitializeInstruction,
    type ParsedCreateGuardInstruction,
    type ParsedExecuteInstruction,
    type ParsedInitializeInstruction,
    type ParsedUpdateGuardInstruction,
    type UpdateGuardAsyncInput,
    type UpdateGuardInstruction,
} from '../instructions';

export const WEN_TRANSFER_GUARD_PROGRAM_ADDRESS =
    'LockdqYQ9X2kwtWB99ioSbxubAmEi8o9jqYwbXgrrRw' as Address<'LockdqYQ9X2kwtWB99ioSbxubAmEi8o9jqYwbXgrrRw'>;

export enum WenTransferGuardAccount {
    GuardV1,
}

export function identifyWenTransferGuardAccount(
    account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): WenTransferGuardAccount {
    const data = 'data' in account ? account.data : account;
    if (
        containsBytes(
            data,
            fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 149, 156, 78, 245, 108, 172, 68])),
            0,
        )
    ) {
        return WenTransferGuardAccount.GuardV1;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, {
        accountData: data,
        programName: 'wenTransferGuard',
    });
}

export enum WenTransferGuardInstruction {
    CreateGuard,
    Execute,
    Initialize,
    UpdateGuard,
}

export function identifyWenTransferGuardInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): WenTransferGuardInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (
        containsBytes(
            data,
            fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([251, 254, 17, 198, 219, 218, 154, 99])),
            0,
        )
    ) {
        return WenTransferGuardInstruction.CreateGuard;
    }
    if (
        containsBytes(
            data,
            fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 37, 101, 197, 75, 251, 102, 26])),
            0,
        )
    ) {
        return WenTransferGuardInstruction.Execute;
    }
    if (
        containsBytes(
            data,
            fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([43, 34, 13, 49, 167, 88, 235, 235])),
            0,
        )
    ) {
        return WenTransferGuardInstruction.Initialize;
    }
    if (
        containsBytes(
            data,
            fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([51, 38, 175, 180, 25, 249, 39, 24])),
            0,
        )
    ) {
        return WenTransferGuardInstruction.UpdateGuard;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, {
        instructionData: data,
        programName: 'wenTransferGuard',
    });
}

export type ParsedWenTransferGuardInstruction<TProgram extends string = 'LockdqYQ9X2kwtWB99ioSbxubAmEi8o9jqYwbXgrrRw'> =
    | ({ instructionType: WenTransferGuardInstruction.CreateGuard } & ParsedCreateGuardInstruction<TProgram>)
    | ({ instructionType: WenTransferGuardInstruction.Execute } & ParsedExecuteInstruction<TProgram>)
    | ({ instructionType: WenTransferGuardInstruction.Initialize } & ParsedInitializeInstruction<TProgram>)
    | ({ instructionType: WenTransferGuardInstruction.UpdateGuard } & ParsedUpdateGuardInstruction<TProgram>);

export function parseWenTransferGuardInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedWenTransferGuardInstruction<TProgram> {
    const instructionType = identifyWenTransferGuardInstruction(instruction);
    switch (instructionType) {
        case WenTransferGuardInstruction.CreateGuard: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: WenTransferGuardInstruction.CreateGuard,
                ...parseCreateGuardInstruction(instruction),
            };
        }
        case WenTransferGuardInstruction.Execute: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: WenTransferGuardInstruction.Execute, ...parseExecuteInstruction(instruction) };
        }
        case WenTransferGuardInstruction.Initialize: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: WenTransferGuardInstruction.Initialize,
                ...parseInitializeInstruction(instruction),
            };
        }
        case WenTransferGuardInstruction.UpdateGuard: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: WenTransferGuardInstruction.UpdateGuard,
                ...parseUpdateGuardInstruction(instruction),
            };
        }
        default:
            throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, {
                instructionType: instructionType as string,
                programName: 'wenTransferGuard',
            });
    }
}

export type WenTransferGuardPlugin = {
    accounts: WenTransferGuardPluginAccounts;
    instructions: WenTransferGuardPluginInstructions;
};

export type WenTransferGuardPluginAccounts = {
    guardV1: ReturnType<typeof getGuardV1Codec> & SelfFetchFunctions<GuardV1Args, GuardV1>;
};

export type WenTransferGuardPluginInstructions = {
    createGuard: (input: CreateGuardAsyncInput) => Promise<CreateGuardInstruction> & SelfPlanAndSendFunctions;
    execute: (input: ExecuteAsyncInput) => Promise<ExecuteInstruction> & SelfPlanAndSendFunctions;
    initialize: (input: InitializeAsyncInput) => Promise<InitializeInstruction> & SelfPlanAndSendFunctions;
    updateGuard: (input: UpdateGuardAsyncInput) => Promise<UpdateGuardInstruction> & SelfPlanAndSendFunctions;
};

export type WenTransferGuardPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> &
    ClientWithPayer &
    ClientWithTransactionPlanning &
    ClientWithTransactionSending;

export function wenTransferGuardProgram() {
    return <T extends WenTransferGuardPluginRequirements>(client: T) => {
        return {
            ...client,
            wenTransferGuard: {
                accounts: { guardV1: addSelfFetchFunctions(client, getGuardV1Codec()) },
                instructions: {
                    createGuard: (input: MakeOptional<CreateGuardAsyncInput, 'payer'>) =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getCreateGuardInstructionAsync({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    execute: (input: ExecuteAsyncInput) =>
                        addSelfPlanAndSendFunctions(client, getExecuteInstructionAsync(input)),
                    initialize: (input: MakeOptional<InitializeAsyncInput, 'payer'>) =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getInitializeInstructionAsync({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    updateGuard: (input: UpdateGuardAsyncInput) =>
                        addSelfPlanAndSendFunctions(client, getUpdateGuardInstructionAsync(input)),
                },
            } as WenTransferGuardPlugin,
        };
    };
}

type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
