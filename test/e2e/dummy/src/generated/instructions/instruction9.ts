/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    combineCodec,
    getAddressDecoder,
    getAddressEncoder,
    getStructDecoder,
    getStructEncoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS,
    SolanaError,
    type AccountMeta,
    type Address,
    type FixedSizeCodec,
    type FixedSizeDecoder,
    type FixedSizeEncoder,
    type Instruction,
    type InstructionWithAccounts,
    type InstructionWithData,
    type ReadonlyAccount,
    type ReadonlyUint8Array,
} from '@solana/kit';
import { getAccountMetaFactory, type ResolvedInstructionAccount } from '@solana/kit/program-client-core';
import { DUMMY_PROGRAM_ADDRESS } from '../programs';

export type Instruction9Instruction<
    TProgram extends string = typeof DUMMY_PROGRAM_ADDRESS,
    TAccountAuthority extends string | AccountMeta<string> = string,
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
    InstructionWithData<ReadonlyUint8Array> &
    InstructionWithAccounts<
        [
            TAccountAuthority extends string ? ReadonlyAccount<TAccountAuthority> : TAccountAuthority,
            ...TRemainingAccounts,
        ]
    >;

export type Instruction9InstructionData = { authority: Address };

export type Instruction9InstructionDataArgs = Instruction9InstructionData;

export function getInstruction9InstructionDataEncoder(): FixedSizeEncoder<Instruction9InstructionDataArgs> {
    return getStructEncoder([['authority', getAddressEncoder()]]);
}

export function getInstruction9InstructionDataDecoder(): FixedSizeDecoder<Instruction9InstructionData> {
    return getStructDecoder([['authority', getAddressDecoder()]]);
}

export function getInstruction9InstructionDataCodec(): FixedSizeCodec<
    Instruction9InstructionDataArgs,
    Instruction9InstructionData
> {
    return combineCodec(getInstruction9InstructionDataEncoder(), getInstruction9InstructionDataDecoder());
}

export type Instruction9Input<TAccountAuthority extends string = string> = {
    authority: Address<TAccountAuthority>;
    authorityArg?: Instruction9InstructionDataArgs['authority'];
};

export function getInstruction9Instruction<
    TAccountAuthority extends string,
    TProgramAddress extends Address = typeof DUMMY_PROGRAM_ADDRESS,
>(
    input: Instruction9Input<TAccountAuthority>,
    config?: { programAddress?: TProgramAddress },
): Instruction9Instruction<TProgramAddress, TAccountAuthority> {
    // Program address.
    const programAddress = config?.programAddress ?? DUMMY_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = { authority: { value: input.authority ?? null, isWritable: false } };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;

    // Original args.
    const args = { ...input, authority: input.authorityArg };

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    return Object.freeze({
        accounts: [getAccountMeta('authority', accounts.authority)],
        data: getInstruction9InstructionDataEncoder().encode(args as Instruction9InstructionDataArgs),
        programAddress,
    } as Instruction9Instruction<TProgramAddress, TAccountAuthority>);
}

export type ParsedInstruction9Instruction<
    TProgram extends string = typeof DUMMY_PROGRAM_ADDRESS,
    TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        authority: TAccountMetas[0];
    };
    data: Instruction9InstructionData;
};

export function parseInstruction9Instruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(
    instruction: Instruction<TProgram> &
        InstructionWithAccounts<TAccountMetas> &
        InstructionWithData<ReadonlyUint8Array>,
): ParsedInstruction9Instruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 1) {
        throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, {
            actualAccountMetas: instruction.accounts.length,
            expectedAccountMetas: 1,
        });
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: { authority: getNextAccount() },
        data: getInstruction9InstructionDataDecoder().decode(instruction.data),
    };
}
