/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    AccountRole,
    type AccountMeta,
    type Address,
    type Instruction,
    type InstructionWithAccounts,
    type TransactionSigner,
} from '@solana/kit';
import { DUMMY_PROGRAM_ADDRESS } from '../programs';

export type Instruction8Instruction<
    TProgram extends string = typeof DUMMY_PROGRAM_ADDRESS,
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> & InstructionWithAccounts<TRemainingAccounts>;

export type Instruction8Input = {
    remainingAccounts?: Array<TransactionSigner | Address>;
};

export function getInstruction8Instruction<TProgramAddress extends Address = typeof DUMMY_PROGRAM_ADDRESS>(
    input: Instruction8Input,
    config?: { programAddress?: TProgramAddress },
): Instruction8Instruction<TProgramAddress> {
    // Program address.
    const programAddress = config?.programAddress ?? DUMMY_PROGRAM_ADDRESS;

    // Original args.
    const args = { ...input };

    // Remaining accounts.
    const remainingAccounts: AccountMeta[] = (args.remainingAccounts ?? []).map(addressOrSigner =>
        typeof addressOrSigner === 'string'
            ? { address: addressOrSigner, role: AccountRole.READONLY }
            : { address: addressOrSigner.address, role: AccountRole.READONLY, signer: addressOrSigner },
    );

    return Object.freeze({ accounts: remainingAccounts, programAddress } as Instruction8Instruction<TProgramAddress>);
}

export type ParsedInstruction8Instruction<TProgram extends string = typeof DUMMY_PROGRAM_ADDRESS> = {
    programAddress: Address<TProgram>;
};

export function parseInstruction8Instruction<TProgram extends string>(
    instruction: Instruction<TProgram>,
): ParsedInstruction8Instruction<TProgram> {
    return { programAddress: instruction.programAddress };
}
