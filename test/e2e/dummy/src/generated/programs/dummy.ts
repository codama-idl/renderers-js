/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    getU32Encoder,
    type Address,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import {
    parseInstruction1Instruction,
    parseInstruction2Instruction,
    parseInstruction3Instruction,
    parseInstruction4Instruction,
    parseInstruction5Instruction,
    parseInstruction6Instruction,
    parseInstruction7Instruction,
    type ParsedInstruction1Instruction,
    type ParsedInstruction2Instruction,
    type ParsedInstruction3Instruction,
    type ParsedInstruction4Instruction,
    type ParsedInstruction5Instruction,
    type ParsedInstruction6Instruction,
    type ParsedInstruction7Instruction,
} from '../instructions';

export const DUMMY_PROGRAM_ADDRESS =
    'Dummy1111111111111111111111111111111111' as Address<'Dummy1111111111111111111111111111111111'>;

export enum DummyInstruction {
    Instruction1,
    Instruction2,
    Instruction3,
    Instruction4,
    Instruction5,
    Instruction6,
    Instruction7,
}

export function identifyDummyInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): DummyInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU32Encoder().encode(42), 0)) {
        return DummyInstruction.Instruction3;
    }
    throw new Error('The provided instruction could not be identified as a dummy instruction.');
}

export type ParsedDummyInstruction<TProgram extends string = 'Dummy1111111111111111111111111111111111'> =
    | ({ instructionType: DummyInstruction.Instruction1 } & ParsedInstruction1Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction2 } & ParsedInstruction2Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction3 } & ParsedInstruction3Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction4 } & ParsedInstruction4Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction5 } & ParsedInstruction5Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction6 } & ParsedInstruction6Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction7 } & ParsedInstruction7Instruction<TProgram>);

export function parseDummyInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedDummyInstruction<TProgram> {
    const instructionType = identifyDummyInstruction(instruction);
    switch (instructionType) {
        case DummyInstruction.Instruction1: {
            return { instructionType: DummyInstruction.Instruction1, ...parseInstruction1Instruction(instruction) };
        }
        case DummyInstruction.Instruction2: {
            return { instructionType: DummyInstruction.Instruction2, ...parseInstruction2Instruction(instruction) };
        }
        case DummyInstruction.Instruction3: {
            return { instructionType: DummyInstruction.Instruction3, ...parseInstruction3Instruction(instruction) };
        }
        case DummyInstruction.Instruction4: {
            return { instructionType: DummyInstruction.Instruction4, ...parseInstruction4Instruction(instruction) };
        }
        case DummyInstruction.Instruction5: {
            return { instructionType: DummyInstruction.Instruction5, ...parseInstruction5Instruction(instruction) };
        }
        case DummyInstruction.Instruction6: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: DummyInstruction.Instruction6, ...parseInstruction6Instruction(instruction) };
        }
        case DummyInstruction.Instruction7: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: DummyInstruction.Instruction7, ...parseInstruction7Instruction(instruction) };
        }
        default:
            throw new Error('Unrecognized instruction type: ' + instructionType);
    }
}
