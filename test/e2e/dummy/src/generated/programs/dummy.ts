/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    getU32Encoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
    SolanaError,
    type Address,
    type ClientWithPayer,
    type ClientWithTransactionPlanning,
    type ClientWithTransactionSending,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import { addSelfPlanAndSendFunctions, type SelfPlanAndSendFunctions } from '@solana/kit/program-client-core';
import {
    getInstruction1Instruction,
    getInstruction2Instruction,
    getInstruction3Instruction,
    getInstruction4Instruction,
    getInstruction5Instruction,
    getInstruction6Instruction,
    getInstruction7Instruction,
    getInstruction8Instruction,
    getInstruction9Instruction,
    parseInstruction1Instruction,
    parseInstruction2Instruction,
    parseInstruction3Instruction,
    parseInstruction4Instruction,
    parseInstruction5Instruction,
    parseInstruction6Instruction,
    parseInstruction7Instruction,
    parseInstruction8Instruction,
    parseInstruction9Instruction,
    type Instruction1Input,
    type Instruction2Input,
    type Instruction3Input,
    type Instruction4Input,
    type Instruction5Input,
    type Instruction6Input,
    type Instruction7Input,
    type Instruction8Input,
    type Instruction9Input,
    type ParsedInstruction1Instruction,
    type ParsedInstruction2Instruction,
    type ParsedInstruction3Instruction,
    type ParsedInstruction4Instruction,
    type ParsedInstruction5Instruction,
    type ParsedInstruction6Instruction,
    type ParsedInstruction7Instruction,
    type ParsedInstruction8Instruction,
    type ParsedInstruction9Instruction,
} from '../instructions';

export const DUMMY_PROGRAM_ADDRESS =
    'Dummy1111111111111111111111111111111111' as Address<'Dummy1111111111111111111111111111111111'>;

export enum DummyInstruction {
    Instruction1,
    Instruction2,
    Instruction3,
    Instruction4,
    Instruction5,
    Instruction6,
    Instruction7,
    Instruction8,
    Instruction9,
}

export function identifyDummyInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): DummyInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU32Encoder().encode(42), 0)) {
        return DummyInstruction.Instruction3;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, {
        instructionData: data,
        programName: 'dummy',
    });
}

export type ParsedDummyInstruction<TProgram extends string = 'Dummy1111111111111111111111111111111111'> =
    | ({ instructionType: DummyInstruction.Instruction1 } & ParsedInstruction1Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction2 } & ParsedInstruction2Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction3 } & ParsedInstruction3Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction4 } & ParsedInstruction4Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction5 } & ParsedInstruction5Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction6 } & ParsedInstruction6Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction7 } & ParsedInstruction7Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction8 } & ParsedInstruction8Instruction<TProgram>)
    | ({ instructionType: DummyInstruction.Instruction9 } & ParsedInstruction9Instruction<TProgram>);

export function parseDummyInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedDummyInstruction<TProgram> {
    const instructionType = identifyDummyInstruction(instruction);
    switch (instructionType) {
        case DummyInstruction.Instruction1: {
            return { instructionType: DummyInstruction.Instruction1, ...parseInstruction1Instruction(instruction) };
        }
        case DummyInstruction.Instruction2: {
            return { instructionType: DummyInstruction.Instruction2, ...parseInstruction2Instruction(instruction) };
        }
        case DummyInstruction.Instruction3: {
            return { instructionType: DummyInstruction.Instruction3, ...parseInstruction3Instruction(instruction) };
        }
        case DummyInstruction.Instruction4: {
            return { instructionType: DummyInstruction.Instruction4, ...parseInstruction4Instruction(instruction) };
        }
        case DummyInstruction.Instruction5: {
            return { instructionType: DummyInstruction.Instruction5, ...parseInstruction5Instruction(instruction) };
        }
        case DummyInstruction.Instruction6: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: DummyInstruction.Instruction6, ...parseInstruction6Instruction(instruction) };
        }
        case DummyInstruction.Instruction7: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: DummyInstruction.Instruction7, ...parseInstruction7Instruction(instruction) };
        }
        case DummyInstruction.Instruction8: {
            return { instructionType: DummyInstruction.Instruction8, ...parseInstruction8Instruction(instruction) };
        }
        case DummyInstruction.Instruction9: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: DummyInstruction.Instruction9, ...parseInstruction9Instruction(instruction) };
        }
        default:
            throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, {
                instructionType: instructionType as string,
                programName: 'dummy',
            });
    }
}

export type DummyPlugin = { instructions: DummyPluginInstructions };

export type DummyPluginInstructions = {
    instruction1: (
        input: Instruction1Input,
    ) => ReturnType<typeof getInstruction1Instruction> & SelfPlanAndSendFunctions;
    instruction2: (
        input: Instruction2Input,
    ) => ReturnType<typeof getInstruction2Instruction> & SelfPlanAndSendFunctions;
    instruction3: (
        input: Instruction3Input,
    ) => ReturnType<typeof getInstruction3Instruction> & SelfPlanAndSendFunctions;
    instruction4: (
        input: Instruction4Input,
    ) => ReturnType<typeof getInstruction4Instruction> & SelfPlanAndSendFunctions;
    instruction5: (
        input: Instruction5Input,
    ) => ReturnType<typeof getInstruction5Instruction> & SelfPlanAndSendFunctions;
    instruction6: (
        input: Instruction6Input,
    ) => ReturnType<typeof getInstruction6Instruction> & SelfPlanAndSendFunctions;
    instruction7: (
        input: Instruction7Input,
    ) => ReturnType<typeof getInstruction7Instruction> & SelfPlanAndSendFunctions;
    instruction8: (
        input: Instruction8Input,
    ) => ReturnType<typeof getInstruction8Instruction> & SelfPlanAndSendFunctions;
    instruction9: (
        input: MakeOptional<Instruction9Input, 'authority' | 'authorityArg'>,
    ) => ReturnType<typeof getInstruction9Instruction> & SelfPlanAndSendFunctions;
};

export type DummyPluginRequirements = ClientWithPayer & ClientWithTransactionPlanning & ClientWithTransactionSending;

export function dummyProgram() {
    return <T extends DummyPluginRequirements>(client: T) => {
        return {
            ...client,
            dummy: {
                instructions: {
                    instruction1: (input: Instruction1Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction1Instruction(input)),
                    instruction2: (input: Instruction2Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction2Instruction(input)),
                    instruction3: (input: Instruction3Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction3Instruction(input)),
                    instruction4: (input: Instruction4Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction4Instruction(input)),
                    instruction5: (input: Instruction5Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction5Instruction(input)),
                    instruction6: (input: Instruction6Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction6Instruction(input)),
                    instruction7: (input: Instruction7Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction7Instruction(input)),
                    instruction8: (input: Instruction8Input) =>
                        addSelfPlanAndSendFunctions(client, getInstruction8Instruction(input)),
                    instruction9: (input: MakeOptional<Instruction9Input, 'authority' | 'authorityArg'>) =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getInstruction9Instruction({
                                ...input,
                                authority: input.authority ?? client.payer.address,
                                authorityArg: input.authorityArg ?? client.payer.address,
                            }),
                        ),
                },
            } as DummyPlugin,
        };
    };
}

type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
